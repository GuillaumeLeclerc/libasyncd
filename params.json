{"name":"Libasyncd","tagline":"Embeddable Event-based Asynchronous Message/HTTP Server library in C","body":"libasyncd\r\n=========\r\n\r\nEmbeddable Event-based Asynchronous Message/HTTP Server library in C.\r\n\r\n## What is libasyncd?\r\n\r\nLibasyncd is an embeddable event-driven asynchronous message server for C/C++.\r\nIt supports HTTP protocol by default and you can add your own protocol handler(hook)\r\nto build your own high performance server.\r\n\r\nAsynchronous way of programming can easily go quite complicated since you need to\r\nhandle every possible things in non-blocking way. So the goal of Libasyncd project is\r\nto make a flexible and fast asynchronous server framework with nice abstraction that\r\ncan cut down the complexity.\r\n\r\n## Why libasyncd?\r\n\r\n* Stands as a generic event-based server library.\r\n* Not only for HTTP server but also as a RPC server, as a Protocol Buffer channel,\r\n  as a Message transforming layer...\r\n* Embeddable library module - you write main().\r\n* Simple to use.\r\n* Pluggable protocols.\r\n* HTTP protocol handler (support chunked transfer-encoding)\r\n* Support of multiple hooks.\r\n* Support request pipelining.\r\n* Support SSL - Just flip the switch on.\r\n\r\n## Compile & Install.\r\n```\r\n$ git clone git clone https://github.com/wolkykim/libasyncd\r\n$ cd libasyncd\r\n$ (cd lib; run2init-submodules.sh; cd qlibc; ./configure; make) \r\n$ ./configure\r\n$ make\r\n```\r\n\r\n## \"Hello World\", Asynchronous Socket Server example.\r\n```\r\nint my_bypass_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    evbuffer_add(conn->out, \"Hello World.\");\r\n    return AD_CLOSE;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    ad_server_t *server = ad_server_new();\r\n    ad_server_set_option(server, \"server.port\", \"2222\");\r\n    ad_server_register_hook(server, my_bypass_handler, NULL);\r\n    return ad_server_start(server);\r\n}\r\n```\r\n\r\n## \"Hello World\", Asynchronous HTTP Server example.\r\n```\r\nint my_bypass_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    if (ad_http_get_status(conn) == AD_HTTP_REQ_DONE) {\r\n        ad_http_response(conn, 200, \"text/html\", \"Hello World\", 11);\r\n        return AD_DONE;\r\n    }\r\n    return AD_OK;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    ad_server_t *server = ad_server_new();\r\n    ad_server_set_option(server, \"server.port\", \"8080\");\r\n    ad_server_register_hook(server, ad_http_handler, NULL); // HTTP Parser is also a hook.\r\n    ad_server_register_hook_on_method(server, \"GET\", my_bypass_handler, NULL); // Put yours after parser.\r\n    return ad_server_start(server);\r\n}\r\n```\r\n\r\n## Looking for more controls? Echo server example here.\r\n\r\n```\r\n/**\r\n * User data for per-connection custom information for non-blocking operation.\r\n */\r\nstruct my_cdata {\r\n    int counter;\r\n};\r\n\r\n/**\r\n * This callback will be called before closing or resetting connection for\r\n * pipelining.\r\n */ \r\nvoid my_userdata_free_cb(ad_conn_t *conn, void *userdata) {\r\n    free(userdata);\r\n}\r\n\r\n/**\r\n * User callback example.\r\n *\r\n * This is a simple echo handler.\r\n * It response on input line up to 3 times then close connection.\r\n *\r\n * @param event event type. see ad_server.h for details.\r\n * @param conn  connection object. type is vary based on\r\n *              \"server.protocol_handler\" option.\r\n * @userdata    given shared user-data.\r\n *\r\n * @return one of AD_OK | AD_DONE | AD_CLOSE | AD_TAKEOVER\r\n *\r\n * @note Please refer ad_server.h for more details.\r\n */\r\nint my_conn_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    DEBUG(\"my_conn_callback: %x\", event);\r\n\r\n    /*\r\n     * AD_EVENT_INIT event is like a constructor method.\r\n     * It happens only once at the beginning of connection.\r\n     * This is a good place to create a per-connection base\r\n     * resources. You can attach it into this connection to\r\n     * use at the next callback cycle.\r\n     */\r\n    if (event & AD_EVENT_INIT) {\r\n        DEBUG(\"==> AD_EVENT_READ\");\r\n        // Allocate a counter container for this connection.\r\n        struct my_cdata *cdata = (struct my_cdata *)calloc(1, sizeof(struct my_cdata));\r\n\r\n        // Attach to this connection.\r\n        ad_conn_set_userdata(conn, cdata, my_userdata_free_cb);\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_READ event happens whenever data comes in.\r\n     */\r\n    else if (event & AD_EVENT_READ) {\r\n        DEBUG(\"==> AD_EVENT_READ\");\r\n\r\n        // Get my per-connection data.\r\n        struct my_cdata *cdata = (struct my_cdata *)ad_conn_get_userdata(conn);\r\n\r\n        // Try to read one line.\r\n        char *data = evbuffer_readln(conn->in, NULL,  EVBUFFER_EOL_ANY);\r\n        if (data) {\r\n            if (!strcmp(data, \"SHUTDOWN\")) {\r\n                //return AD_SHUTDOWN;\r\n            }\r\n            cdata->counter++;\r\n            evbuffer_add_printf(conn->out, \"%s, counter:%d, userdata:%s\\n\", data, cdata->counter, (char*)userdata);\r\n            free(data);\r\n        }\r\n\r\n        // Close connection after 3 echos.\r\n        return (cdata->counter < 3) ? AD_OK : AD_CLOSE;\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_WRITE event happens whenever out-buffer has lesser than certain\r\n     * amount of data.\r\n     *\r\n     * Default watermark is 0 meaning this will happens when out-buffer is empty.\r\n     * For reasonable size of message, you can send it all at once but for a large\r\n     * amount of data, you need to send it out through out multiple callbacks.\r\n     *\r\n     * To maximize the performance, you will also want to set higher watermark\r\n     * so whenever the level goes below the watermark you will be called for the\r\n     * refill work before the buffer gets empty. So it's just faster if you can\r\n     * fill up gas while you're driving without a stop.\r\n     */\r\n    else if (event & AD_EVENT_WRITE) {\r\n        DEBUG(\"==> AD_EVENT_WRITE\");\r\n        // We've sent all the data in out-buffer.\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_CLOSE event happens right before closing connection.\r\n     * This will be the last callback for this connection.\r\n     * So if you have created per-connection data then release the resource.\r\n     */\r\n    else if (event & AD_EVENT_CLOSE) {\r\n        DEBUG(\"==> AD_EVENT_CLOSE=%x (TIMEOUT=%d, SHUTDOWN=%d)\",\r\n              event, event & AD_EVENT_TIMEOUT, event & AD_EVENT_SHUTDOWN);\r\n        // You can release your user data explicitly here if you haven't\r\n        // set the callback that release your user data.\r\n    }\r\n\r\n    // Return AD_OK will let the hook loop to continue.\r\n    return AD_OK;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    // Example shared user data.\r\n    char *userdata = \"SHARED-USERDATA\";\r\n\r\n    //\r\n    // Create a server.\r\n    //\r\n    ad_server_t *server = ad_server_new();\r\n\r\n    //\r\n    // Set server options.\r\n    //\r\n    // Usually you only need to override a few default options and\r\n    // that's it but it's lengthy here for a demonstration purpose.\r\n    //\r\n    ad_server_set_option(server, \"server.port\", \"2222\");\r\n    ad_server_set_option(server, \"server.addr\", \"0.0.0.0\");\r\n    ad_server_set_option(server, \"server.timeout\", \"5\");\r\n\r\n    // Set protocol handler.\r\n    //   - bypass : Use bypass handler. This is a transparent handler for\r\n    //              build an custom protocols.\r\n    //   - http   : Use HTTP handler. Request message will be parsed by\r\n    //              the handler. You can put your hooks on method name or\r\n    //              on each phase of parsing process like \"AFTER_HEADER\".\r\n    //   - euca   : Use EUCA handler. This handler is for EUCA message.\r\n    //              light weight messaging protocol designed for the\r\n    //              blasting fast performance in data exchange.\r\n    ad_server_set_option(server, \"server.protocol_handler\", \"http\");\r\n\r\n    // Register custom hooks. When there are multiple hooks, it will be\r\n    // executed in the same order as it registered.\r\n    ad_server_register_hook(server, my_conn_handler, userdata);\r\n\r\n    // SSL options.\r\n    ad_server_set_option(server, \"server.server.enable_ssl\", \"0\");\r\n    ad_server_set_option(server, \"server.ssl_cert\", \"/usr/local/etc/ad_server/ad_server.cert\");\r\n    ad_server_set_option(server, \"server.ssl_pkey\", \"/usr/local/etc/ad_server/ad_server.pkey\");\r\n\r\n    // Enable request pipelining, this change AD_DONE's behavior.\r\n    ad_server_set_option(server, \"server.request_pipelining\", \"1\");\r\n\r\n    // Run server in a separate thread. If you want to run multiple\r\n    // server instances or if you want to run it in background, this\r\n    // is the option.\r\n    ad_server_set_option(server, \"server.daemon\", \"0\");\r\n\r\n    // Call ad_server_free() internally when server is shutting down.\r\n    ad_server_set_option(server, \"server.free_on_stop\", \"1\");\r\n\r\n    //\r\n    // Start server.\r\n    //\r\n    int retstatus = ad_server_start(server);\r\n\r\n    //\r\n    // That is it!!!\r\n    //\r\n    return retstatus;\r\n}\r\n```\r\n\r\n## References\r\n\r\n* [C10K problem](http://en.wikipedia.org/wiki/C10k_problem)\r\n* [libevent library - an event notification library](http://libevent.org/)\r\n* [qLibc library - a STL like C library](http://wolkykim.github.io/qlibc/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}