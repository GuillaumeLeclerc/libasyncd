{"name":"Libasyncd","tagline":"Embeddable Event-based Asynchronous Message/HTTP Server library in C","body":"libasyncd\r\n=========\r\n\r\nEmbeddable Event-based Asynchronous Message/HTTP Server library in C.\r\n\r\n## What is libasyncd?\r\n\r\nLibasyncd is an embeddable fully event-driven asynchronous message server in C\r\nwhich is in flexible architecture to add/support multiple different protocols.\r\n\r\nLibasyncd project was started from my need of embeddable HTTP server. There is\r\na couple of choices there, I tried all of them. Each has pros and cons.\r\nI couldn't pick my favorite at the end and here's my insight.\r\n\r\n* libevent provides one - good choice for light use but doesn't provide a way\r\n  of fine controls over large data.\r\n* mongoose - nice API, good abstraction, but since it uses select() and realloc\r\n  based i/o buffer, wouldn't be a promising solution for serious users.\r\n  Also its dual lisencing is restricting.\r\n* libevhtp - fine but doesn't provide a way to hook on METHOD(Verb, a command\r\n  on the 1st line)\r\n* GNU's libmicrohttpd - good feature set but little too complicated to use.\r\n\r\nWhat I was looking for was.\r\n\r\n* Must be easily embeddable.\r\n* Simple and nice abstraction that cut down the complexity.\r\n* Generic enough to add and customize lighter weight custom protocols.\r\n* Practical level of support in HTTP handler.\r\n* Flexible hook supports on both Method hook and Gradual way.\r\n* Snap-on SSL feature.\r\n\r\nSo with these feature set, applications can expose RESTful API as customer facing\r\ninterface and also use more lighter weight protocols for inter communication\r\nwithout doing integration work between this modules and that modules.\r\n\r\nAsynchronous way of programming can easily go quite complicated as more things\r\nyou handle in nonblocking passion. So the goal of Libasyncd project is to make\r\na flexible and fast event-based message server base with good abstraction.\r\n\r\nHope you find libasyncd is useful and help us to make a fast event server\r\nwithout thinking much about the underneath complexity.\r\n\r\n## Why libasyncd?\r\n\r\n* Stands as a generic event-based server library.\r\n* Not only for HTTP server but also as a RPC server, as a Protocol Buffer channel,\r\n  as a Message transforming layer...\r\n* Embeddable library module - you write main().\r\n* Simple to use.\r\n* Pluggable protocols. HTTP protocol handler is included.\r\n* Support of multiple hooks.\r\n* Support request pipelining.\r\n* Support SSL - Just flip the switch on.\r\n\r\n## Compile & Install.\r\n```\r\n$ git clone git clone https://github.com/wolkykim/libasyncd\r\n$ cd libasyncd\r\n$ (cd lib; run2init-submodules.sh; cd qlibc; ./configure; make) \r\n$ ./configure\r\n$ make\r\n```\r\n\r\n## \"Hello World\", Asynchronous Socket Server example.\r\n```\r\nint my_bypass_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    evbuffer_add(conn->out, \"Hello World.\");\r\n    return AD_CLOSE;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    ad_server_t *server = ad_server_new();\r\n    ad_server_set_option(server, \"server.port\", \"2222\");\r\n    ad_server_register_hook(server, my_bypass_handler, NULL);\r\n    return ad_server_start(server);\r\n}\r\n```\r\n\r\n## \"Hello World\", Asynchronous HTTP Server example.\r\n```\r\nint my_bypass_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    if (ad_http_get_status(conn) == AD_HTTP_REQ_DONE) {\r\n        ad_http_response(conn, 200, \"text/html\", \"Hello World\", 11);\r\n        return AD_DONE;\r\n    }\r\n    return AD_OK;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    ad_server_t *server = ad_server_new();\r\n    ad_server_set_option(server, \"server.port\", \"8080\");\r\n    ad_server_register_hook(server, ad_http_handler, NULL); // HTTP Parser is also a hook.\r\n    ad_server_register_hook_on_method(server, \"GET\", my_bypass_handler, NULL); // Put yours after parser.\r\n    return ad_server_start(server);\r\n}\r\n```\r\n\r\n## Looking for more controls? Echo server example here.\r\n\r\n```\r\n/**\r\n * User data for per-connection custom information for non-blocking operation.\r\n */\r\nstruct my_cdata {\r\n    int counter;\r\n};\r\n\r\n/**\r\n * This callback will be called before closing or resetting connection for\r\n * pipelining.\r\n */ \r\nvoid my_userdata_free_cb(ad_conn_t *conn, void *userdata) {\r\n    free(userdata);\r\n}\r\n\r\n/**\r\n * User callback example.\r\n *\r\n * This is a simple echo handler.\r\n * It response on input line up to 3 times then close connection.\r\n *\r\n * @param event event type. see ad_server.h for details.\r\n * @param conn  connection object. type is vary based on\r\n *              \"server.protocol_handler\" option.\r\n * @userdata    given shared user-data.\r\n *\r\n * @return one of AD_OK | AD_DONE | AD_CLOSE | AD_TAKEOVER\r\n *\r\n * @note Please refer ad_server.h for more details.\r\n */\r\nint my_conn_handler(short event, ad_conn_t *conn, void *userdata) {\r\n    DEBUG(\"my_conn_callback: %x\", event);\r\n\r\n    /*\r\n     * AD_EVENT_INIT event is like a constructor method.\r\n     * It happens only once at the beginning of connection.\r\n     * This is a good place to create a per-connection base\r\n     * resources. You can attach it into this connection to\r\n     * use at the next callback cycle.\r\n     */\r\n    if (event & AD_EVENT_INIT) {\r\n        DEBUG(\"==> AD_EVENT_READ\");\r\n        // Allocate a counter container for this connection.\r\n        struct my_cdata *cdata = (struct my_cdata *)calloc(1, sizeof(struct my_cdata));\r\n\r\n        // Attach to this connection.\r\n        ad_conn_set_userdata(conn, cdata, my_userdata_free_cb);\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_READ event happens whenever data comes in.\r\n     */\r\n    else if (event & AD_EVENT_READ) {\r\n        DEBUG(\"==> AD_EVENT_READ\");\r\n\r\n        // Get my per-connection data.\r\n        struct my_cdata *cdata = (struct my_cdata *)ad_conn_get_userdata(conn);\r\n\r\n        // Try to read one line.\r\n        char *data = evbuffer_readln(conn->in, NULL,  EVBUFFER_EOL_ANY);\r\n        if (data) {\r\n            if (!strcmp(data, \"SHUTDOWN\")) {\r\n                //return AD_SHUTDOWN;\r\n            }\r\n            cdata->counter++;\r\n            evbuffer_add_printf(conn->out, \"%s, counter:%d, userdata:%s\\n\", data, cdata->counter, (char*)userdata);\r\n            free(data);\r\n        }\r\n\r\n        // Close connection after 3 echos.\r\n        return (cdata->counter < 3) ? AD_OK : AD_CLOSE;\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_WRITE event happens whenever out-buffer has lesser than certain\r\n     * amount of data.\r\n     *\r\n     * Default watermark is 0 meaning this will happens when out-buffer is empty.\r\n     * For reasonable size of message, you can send it all at once but for a large\r\n     * amount of data, you need to send it out through out multiple callbacks.\r\n     *\r\n     * To maximize the performance, you will also want to set higher watermark\r\n     * so whenever the level goes below the watermark you will be called for the\r\n     * refill work before the buffer gets empty. So it's just faster if you can\r\n     * fill up gas while you're driving without a stop.\r\n     */\r\n    else if (event & AD_EVENT_WRITE) {\r\n        DEBUG(\"==> AD_EVENT_WRITE\");\r\n        // We've sent all the data in out-buffer.\r\n    }\r\n\r\n    /*\r\n     * AD_EVENT_CLOSE event happens right before closing connection.\r\n     * This will be the last callback for this connection.\r\n     * So if you have created per-connection data then release the resource.\r\n     */\r\n    else if (event & AD_EVENT_CLOSE) {\r\n        DEBUG(\"==> AD_EVENT_CLOSE=%x (TIMEOUT=%d, SHUTDOWN=%d)\",\r\n              event, event & AD_EVENT_TIMEOUT, event & AD_EVENT_SHUTDOWN);\r\n        // You can release your user data explicitly here if you haven't\r\n        // set the callback that release your user data.\r\n    }\r\n\r\n    // Return AD_OK will let the hook loop to continue.\r\n    return AD_OK;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n    // Example shared user data.\r\n    char *userdata = \"SHARED-USERDATA\";\r\n\r\n    //\r\n    // Create a server.\r\n    //\r\n    ad_server_t *server = ad_server_new();\r\n\r\n    //\r\n    // Set server options.\r\n    //\r\n    // Usually you only need to override a few default options and\r\n    // that's it but it's lengthy here for a demonstration purpose.\r\n    //\r\n    ad_server_set_option(server, \"server.port\", \"2222\");\r\n    ad_server_set_option(server, \"server.addr\", \"0.0.0.0\");\r\n    ad_server_set_option(server, \"server.timeout\", \"5\");\r\n\r\n    // Set protocol handler.\r\n    //   - bypass : Use bypass handler. This is a transparent handler for\r\n    //              build an custom protocols.\r\n    //   - http   : Use HTTP handler. Request message will be parsed by\r\n    //              the handler. You can put your hooks on method name or\r\n    //              on each phase of parsing process like \"AFTER_HEADER\".\r\n    //   - euca   : Use EUCA handler. This handler is for EUCA message.\r\n    //              light weight messaging protocol designed for the\r\n    //              blasting fast performance in data exchange.\r\n    ad_server_set_option(server, \"server.protocol_handler\", \"http\");\r\n\r\n    // Register custom hooks. When there are multiple hooks, it will be\r\n    // executed in the same order as it registered.\r\n    ad_server_register_hook(server, my_conn_handler, userdata);\r\n\r\n    // SSL options. - Not implemented yet.\r\n    ad_server_set_option(server, \"server.server.enable_ssl\", \"0\");\r\n    ad_server_set_option(server, \"server.ssl_cert\", \"/usr/local/etc/ad_server/ad_server.cert\");\r\n\r\n    // Enable request pipelining, this change AD_DONE's behavior.\r\n    ad_server_set_option(server, \"server.request_pipelining\", \"1\");\r\n\r\n    // Run server in a separate thread. If you want to run multiple\r\n    // server instances or if you want to run it in background, this\r\n    // is the option.\r\n    ad_server_set_option(server, \"server.start_detached\", \"0\");\r\n\r\n    // Call ad_server_free() internally when server is shutting down.\r\n    ad_server_set_option(server, \"server.free_on_stop\", \"1\");\r\n\r\n    //\r\n    // Start server.\r\n    //\r\n    int retstatus = ad_server_start(server);\r\n\r\n    //\r\n    // That is it!!!\r\n    //\r\n    return retstatus;\r\n}\r\n```\r\n\r\n## References\r\n\r\n* [C10K problem](http://en.wikipedia.org/wiki/C10k_problem)\r\n* [libevent library - an event notification library](http://libevent.org/)\r\n* [qLibc library - a STL like C library](http://wolkykim.github.io/qlibc/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}